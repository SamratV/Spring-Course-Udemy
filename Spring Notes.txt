Download the jars from: https://repo.spring.io/release/org/springframework/spring/

****************************************************************************************************************************************************************************************************************************************************

Inversion of Control (IoC): The approach of outsourcing the construction and management of objects.

Spring Container > Primary Functions:
• Create and manage objects (Inversion of Control)
• Inject object’s dependencies (Dependency Injection)

Configuring Spring Container
• XML configuration file (legacy, but most legacy apps still use this)
• Java Annotations (modern)
• Java Source Code (modern)

Spring Development Process
1. Configure your Spring Beans
2. Create a Spring Container
3. Retrieve Beans from Spring Container

In newer spring versions by default logging is disabled. Refer "HEADS UP" video in IoC section to enable logging. (Video number: 25)

****************************************************************************************************************************************************************************************************************************************************

Dependency Injection (The dependency inversion principle):
• The client delegates to calls to another object the responsibility of providing its dependencies.
• Injecting helper objects.

Injection Types
• There are many types of injection with Spring
• We will cover the two most common
    • Constructor Injection
    • Setter Injection
• Will talk about “auto-wiring” in the Annotations section later

Development Process - Constructor Injection
1. Define the dependency interface and class
2. Create a constructor in your class for injections
3. Configure the dependency injection in Spring config file

Development Process - Setter Injection
1. Create setter method(s) in your class for injections
2. Configure the dependency injection in Spring config file

Development Process - Properties File
1. Create Properties File
2. Load Properties File in Spring config file
3. Reference values from Properties File

****************************************************************************************************************************************************************************************************************************************************

Bean Scopes
• Scope refers to the lifecycle of a bean
• How long does the bean live?
• How many instances are created?
• How is the bean shared?

Default Scope: Singleton

What Is a Singleton?
• Spring Container creates only one instance of the bean, by default
• It is cached in memory
• All requests for the bean will return a SHARED reference to the SAME bean

Spring Bean Scopes
• singleton         : Create a single shared instance of the bean. Default scope.
• prototype         : Creates a new bean instance for each container request.
• request           : Scoped to an HTTP web request. Only used for web apps.
• session           : Scoped to an HTTP web session. Only used for web apps.
• global-session    : Scoped to a global HTTP web session. Only used for web apps.

Bean Lifecycle
    # Start:-
        STEP 1: Container Started
        STEP 2: Bean Instantiated
        STEP 3: Dependencies Injected
        STEP 4: Internal Spring Processing
        STEP 5: Your Custom Init Method --> USER DEFINED
        STEP 6: Bean Is Ready For Use

    # Stop:-
        STEP 1: Your Custom Destroy Method --> USER DEFINED
        STEP 2: Stop the container

    # Development Process:-
        STEP 1: Define your methods for init and destroy
        STEP 2: Configure the method names in Spring config file

    # Special Note about init and destroy Method Signatures:-
        When using XML configuration; the additional details regarding the method signatures of the init-method and destroy-method are as follows.

        • Access modifier:
            > The method can have any access modifier (public, protected, private).
        • Return type:
            > The method can have any return type.
            > However, "void' is most commonly used.
            > If you give a return type just note that you will not be able to capture the return value.
            > As a result, "void" is commonly used.
        • Method name:
            > The method can have any method name.
        • Arguments:
            > The method can not accept any arguments.
            > The method should be no-arg.

    # Special Note about Destroy Lifecycle and Prototype Scope:-
        There is a subtle point you need to be aware of with "prototype" scoped beans.

        • For "prototype" scoped beans, Spring does not call the destroy method.
        • In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean:
          the container instantiates, configures, and otherwise assembles a prototype object, and hands it to the client,
          with no further record of that prototype instance.
        • Thus, although initialization lifecycle callback methods are called on all objects regardless of scope,
          in the case of prototypes, configured destruction lifecycle callbacks are not called.
          The client code must clean up prototype-scoped objects and release expensive resources that the prototype bean(s) are holding. 
        • This also applies to both XML configuration and Annotation-based configuration.

****************************************************************************************************************************************************************************************************************************************************

What are Java Annotations?
• Special labels/markers added to Java classes
• Provides meta-data about the class
• Processed at compile time or run-time for special processing

Why Spring Configuration with Annotations?
• XML configuration can be verbose
• Configure your Spring beans with Annotations
• Annotations minimizes the XML configuration

Scanning for Component Classes
• Spring will scan your Java classes for special annotations
• Automatically register the beans in the Spring container

Development Process
1. Enable component scanning in Spring config file
2. Add the @Component Annotation to your Java classes
3. Retrieve bean from Spring container

Spring also supports Default Bean IDs
• Though we can give a bean any ID of our liking but default ID is generally used 
• Default bean id: the class name, make first letter lower-case
• Example: TennisCoach (Class Name) => tennisCoach (Default Bean Id)

****************************************************************************************************************************************************************************************************************************************************

What is Spring AutoWiring?
    • For dependency injection, Spring can use auto wiring
    • Spring will look for a class that matches the property
    • Matches by type: class or interface
    • Spring will inject it automatically … hence it is autowired

Autowiring Injection Types
    • Constructor Injection
    • Setter Injection
    • Field Injections

Development Process - Constructor Injection
    1. Define the dependency interface and class
    2. Create a constructor in your class for injections
    3. Configure the dependency injection with @Autowired Annotation

What if there are multiple FortuneService(Autowired Object) implementations?
    Spring has special support to handle this case. Use the @Qualifier annotation.

Autowired - (Refer: "BaseballCoach" class in the third project part 1.)
    • As of Spring Framework 4.3, an @Autowired annotation on such a constructor is
    no longer necessary if the target bean only defines one constructor to begin with.
    However, if several constructors are available, at least one must be annotated to
    teach the container which one to use.
    • I personally prefer to use the @Autowired annotation because it makes the code more
    readable. But as mentioned, the @Autowired is not required for this scenario.

Development Process - Setter Injection
    1. Create setter method(s) in your class for injections
    2. Configure the dependency injection with @Autowired Annotation

Development Process - Method Injection
    1. Create method(s) in your class for injections
    2. Configure the dependency injection with @Autowired Annotation

Field Injection - Inject dependencies by setting field values on your class directly (even private fields). Accomplished by using Java Reflection.

Development Process - Field Injection
    1. Configure the dependency injection with Autowired Annotation
        ✤ Applied directly to the field
        ✤ No need for setter methods

Annotations - Default Bean Names and the Special Case
    In general, when using Annotations, for the default bean name, Spring uses the following rule.
    If the annotation's value doesn't indicate a bean name, an appropriate name will be built based
    on the short name of the class (with the first letter lower-cased). For example:
    HappyFortuneService --> happyFortuneService

    However, for the special case of when BOTH the first and second characters of the class name are
    upper case, then the name is NOT converted. For example: RESTFortuneService --> RESTFortuneService

    No conversion since the first two characters are upper case. Behind the scenes, Spring uses the
    Java Beans Introspector to generate the default bean name. Here's a link to the documentation:
    https://docs.oracle.com/javase/8/docs/api/java/beans/Introspector.html#decapitalize(java.lang.String)

    As always, you can give explicit names to your beans.

    @Component("foo")
    public class RESTFortuneService .... {
        
    }

    Then you can access it using the name of "foo".

Using @Qualifier with Constructors
    @Qualifier is a nice feature, but it is tricky when used with Constructors.
    The syntax is much different from other examples and not exactly intuitive. 
    You have to place the @Qualifier annotation inside of the constructor arguments. 
    Here's an example:

        @Component
        public class TennisCoach implements Coach {

            .....

            @Autowired
            public TennisCoach(@Qualifier("randomFortuneService") FortuneService theFortuneService) {
                fortuneService = theFortuneService;
            }

            .....

        }

    For detailed documentation on using @Qualifier with Constructors, see the following link:
    https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation-qualifiers

When Spring creates the beans it follows this general process
    1. Construct an instance of class
    2. Inject dependencies
    3. Set properties etc (@Value)

****************************************************************************************************************************************************************************************************************************************************

Bean Scope with annotations
    1) Singleton

        @Component
        @Scope("singleton")
        public class TennisCoach implements Coach {
        ...
        }

    2) Prototype

        @Component
        @Scope("prototype")
        public class TennisCoach implements Coach {
        ...
        }

Development Process - Bean Lifecycle Methods - Annotations
    1. Define your methods for init and destroy
    2. Add annotations: @PostConstruct and @PreDestroy

Special Note about @PostConstruct and @PreDestroy Method Signatures
    I want to provide additional details regarding the method signatures of @PostContruct and @PreDestroy methods.

    Access modifier
        The method can have any access modifier (public, protected, private).

    Return type
        The method can have any return type. However, "void' is most commonly used.
        If you give a return type just note that you will not be able to capture the return value.
        As a result, "void" is commonly used.

    Method name
        The method can have any method name.

    Arguments
        The method can not accept any arguments. The method should be no-arg.

HEADS UP - FOR JAVA 9, 10 and 11 USERS - @PostConstruct and @PreDestroy
    If you are using Java 9 or higher, then you will encounter an error when using
    @PostConstruct and @PreDestroy in your code. These are the steps to resolve it.

    Error: Eclipse is unable to import @PostConstruct or @PreDestroy

    This happens because of Java 9 and higher. When using Java 9 and higher,
    javax.annotation has been removed from its default classpath. That's why
    Eclipse can't find it.

    Solution:
        1. Download the javax.annotation-api-1.3.2.jar from: 
        https://search.maven.org/remotecontent?filepath=javax/annotation/javax.annotation-api/1.3.2/javax.annotation-api-1.3.2.jar

        2. Copy the JAR file to the lib folder of your project.

        Use the following steps to add it to your Java Build Path.
        3. Right-click your project, select Properties.
        4. On left-hand side, click Java Build Path.
        5. In top-center of dialog, click Libraries.
        6. Click Classpath and then click Add JARs ...
        7. Navigate to the JAR file <your-project>/lib/javax.annotation-api-1.3.2.jar.
        8. Click OK then click Apply and Close.

        Eclipse will perform a rebuild of your project and it will resolve the related build errors.

Special Note about Destroy Lifecycle and Prototype Scope
    Here is a subtle point you need to be aware of with "prototype" scoped beans.
    For "prototype" scoped beans, Spring does not call the @PreDestroy method.

    Here is the answer from the Spring reference manual. Section 1.5.2:
    https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-prototype

    In contrast to the other scopes, Spring does not manage the complete lifecycle of a
    prototype bean: the container instantiates, configures, and otherwise assembles a
    prototype object, and hands it to the client, with no further record of that prototype
    instance.

    Thus, although initialization lifecycle callback methods are called on all objects
    regardless of scope, in the case of prototypes, configured destruction lifecycle
    callbacks are not called. The client code must clean up prototype-scoped objects
    and release expensive resources that the prototype bean(s) are holding. 

    To get the Spring container to release resources held by prototype-scoped beans,
    try using a custom bean post-processor, which holds a reference to beans that
    need to be cleaned up.

    This also applies to XML configuration.

    QUESTION: How can I create code to call the destroy method on prototype scope beans?
    ANSWER:
        You can destroy prototype beans but custom coding is required.
        This examples shows how to destroy prototype scoped beans.

        1. Create a custom bean processor. This bean processor will keep track of prototype scoped
        beans. During shutdown it will call the destroy() method on the prototype scoped beans.

        2. The prototype scoped beans MUST implement the DisposableBean interface. This interface
        defines a "destory()" method. This method should be used instead of the @PreDestroy annotation.

        3. In this app, BeanProcessorDemoApp.java is the main program. TennisCoach.java is the prototype
        scoped bean. TennisCoach implements the DisposableBean interface and provides the destroy() method.
        The custom bean processing is handled in the MyCustomBeanProcessor class.

        See source code in the project named: 3-spring-config-with-annotations-part-3

****************************************************************************************************************************************************************************************************************************************************

Java Configuration
    • Instead of configuring Spring container using XML
    • Configure the Spring container with Java code

3 Ways of Configuring Spring Container
    1. Full XML Config (Project number 1 & 2)
    2. XML Component Scan (Project number 3 - all 3 parts)
    3. Java Configuration Class (Project number 4)

Development Process - Java Configuration Class
    1. Create a Java class and annotate as @Configuration
    2. Add component scanning support: @ComponentScan (optional)
    3. Read Spring Java configuration class
    4. Retrieve bean from Spring container

In newer spring versions by default logging is disabled. Refer "HEADS UP" video (Video number: 86) OR refer forked gist on GitHub.

Development Process - Defining Bean - Java Configuration Class
    1. Define method to expose bean
    2. Inject bean dependencies
    3. Read Spring Java configuration class
    4. Retrieve bean from Spring container

Development Process - Properties File - Java Configuration Class
    1. Create Properties File
    2. Load Properties File in Spring config
    3. Reference values from Properties File

****************************************************************************************************************************************************************************************************************************************************

What is Spring MVC?
    • Framework for building web applications in Java
    • Based on Model-View-Controller design pattern
    • Leverages features of the Core Spring Framework (IoC, DI)

Spring MVC Benefits
    • The Spring way of building web app UIs in Java
    • Leverage a set of reusable UI components
    • Help manage application state for web requests
    • Process form data: validation, conversion etc
    • Flexible configuration for the view layer

Components of a Spring MVC Application
    • A set of web pages to layout UI components
    • A collection of Spring beans (controllers, services, etc…)
    • Spring configuration (XML, Annotations or Java)

Web Browser --> Front Controller --(Model)--> Controller --(Model)--> View Template --> Web Browser

Front Controller:
    • Front controller known as DispatcherServlet.
    • Part of the Spring Framework.
    • Already developed by Spring Dev Team.

Controller:
    • Code created by developer
    • Contains your business logic
        • Handle the request
        • Store/retrieve data (db, web service…)
        • Place data in model
    • Send to appropriate view template

Model:
    • Contains your data
    • Store/retrieve data via backend systems
        • database, web service, etc…
        • Use a Spring bean if you like
    • Place your data in the model
        • Data can be any Java object/collection

View Template:
    • Spring MVC is flexible
        • Supports many view templates
    • Most common is JSP + JSTL
    • Developer creates a page
        • Displays data

------------------------------------------------------------------------------------------------------------
|Spring MVC Configuration Process - Part 1                                                                 |
------------------------------------------------------------------------------------------------------------
|   Add configurations to file: WEB-INF/web.xml                                                            |
|        STEP 1: CONFIGURE SPRING DISPATCHER SERVLET                                                       |
|            <web-app>                                                                                     |
|                <servlet>                                                                                 |
|                    <servlet-name>dispatcher</servlet-name>                                               |
|                    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>      |
|                    <init-param>                                                                          |
|                        <param-name>contextConfigLocation</param-name>                                    |
|                        <param-value>/WEB-INF/spring-mvc-demo-servlet.xml</param-value>                   |
|                    </init-param>                                                                         |
|                    <load-on-startup>1</load-on-startup>                                                  |
|                </servlet>                                                                                |
|            </web-app>                                                                                    |
|                                                                                                          |
|        STEP 2: SET UP URL MAPPINGS TO SPRING MVC DISPATCHER SERVLET                                      |
|            <web-app>                                                                                     |
|                <servlet>                                                                                 |
|                    <servlet-name>dispatcher</servlet-name>                                               |
|                    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>      |
|                    ...                                                                                   |
|                </servlet>                                                                                |
|                <servlet-mapping>                                                                         |
|                    <servlet-name>dispatcher</servlet-name>                                               |
|                    <url-pattern>/</url-pattern>                                                          |
|               </servlet-mapping>                                                                         |
|            </web-app>                                                                                    |
------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------
|Spring MVC Configuration Process - Part 2                                                                 |
------------------------------------------------------------------------------------------------------------
|    Add configurations to file: WEB-INF/spring-mvc-demo-servlet.xml                                       |
|        STEP 3: ADD SUPPORT FOR SPRING COMPONENT SCANNING                                                 |
|            <beans>                                                                                       |
|                <!-- Step 3: Add support for component scanning -->                                       |
|                <context:component-scan base-package="com.luv2code.springdemo" />                         |
|            </beans>                                                                                      |
|                                                                                                          |
|        STEP 4: ADD SUPPORT FOR CONVERSION, FORMATTING AND VALIDATION                                     |
|            <beans>                                                                                       |
|                <!-- Step 3: Add support for component scanning -->                                       |
|                <context:component-scan base-package="com.luv2code.springdemo" />                         |
|                <!-- Step 4: Add support for conversion, formatting and validation support -->            |
|                <mvc:annotation-driven/>                                                                  |
|            </beans>                                                                                      |
|                                                                                                          |
|        STEP 5: CONFIGURE SPRING MVC VIEW RESOLVER                                                        |
|            <beans>                                                                                       |
|                <!-- Step 3: Add support for component scanning -->                                       |
|                <context:component-scan base-package="com.luv2code.springdemo" />                         |
|                <!-- Step 4: Add support for conversion, formatting and validation support -->            |
|                <mvc:annotation-driven/>                                                                  |
|                <!-- Step 5: Define Spring MVC view resolver -->                                          |
|                <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">          |
|                    <property name="prefix" value="/WEB-INF/view/" />                                     |
|                    <property name="suffix" value=".jsp" />                                               |
|                </bean>                                                                                   |
|            </beans>                                                                                      |
------------------------------------------------------------------------------------------------------------

Development Process - Spring MVC
    1. Create Controller class

        @Controller
        public class HomeController {
        }

    2. Define Controller method

        @Controller
        public class HomeController {
            public String showMyPage() {
            …
            }
        }

    3. Add Request Mapping to Controller method
        
        @Controller
        public class HomeController {
            @RequestMapping("/")
            public String showMyPage() {
            …
            }
        }

    4. Return View Name

        @Controller
        public class HomeController {
            @RequestMapping("/")
            public String showMyPage() {
                return "main-menu";
            }
        }

    5. Develop View Page - File: /WEB-INF/view/main-menu.jsp

        <html>
            <body>
                <h2>Spring MVC Demo - Home Page</h2>
            </body>
        </html>

QUESTION: How do I use CSS, JavaScript and Images in a Spring MVC Web App?
ANSWER:
    Here are the steps on how to access static resources in a Spring MVC.
    For example, you can use this to access images, css, JavaScript files etc.
    Any static resource is processed as a URL Mapping in Spring MVC. You can
    configure references to static resources in the spring-mvc-demo-servlet.xml.

    In my example, I'm going to have the following directory structure:

        I chose to put everything in the "resources" directory. But you can use any
        name for "resources", such as "assets", "foobar" etc. Also, you can give any
        name that you want for the subdirectories under "resources".

    ---

    Step 1: Add the following entry to your Spring MVC configuration file: spring-mvc-demo-servlet.xml
        You can place this entry anywhere in your Spring MVC config file.
        <mvc:resources mapping="/resources/**" location="/resources/"></mvc:resources>

        "resources" folder is placed inside "WebContent" folder.

    Step 2: Now in your view pages, you can access the static files using this syntax:
        <img src="${pageContext.request.contextPath}/resources/images/spring-logo.png">
        You need to use the JSP expression ${pageContext.request.contextPath} to access
        the correct root directory for your web application.

    Apply the same technique for reading CSS and JavaScript. In case of doubt refer forked gists on GitHub.

Spring MVC Form Tags
    • Spring MVC Form Tags are the building block for a web page
    • Form Tags are configurable and reusable for a web page
    • Form tags will generate HTML for you
        • form:form - main form container
        • form:input - text field
        • form:textarea - multi-line text field
        • form:checkbox - check box
        • form:radiobutton - radio buttons
        • form:select - drop down list
        • more …

Data Binding
    • Spring MVC Form Tags can make use of data binding
    • Automatically setting / retrieving data from a Java object / bean

How To Reference Spring MVC Form Tags
    • Specify the Spring namespace at beginning of JSP file
        <%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>

Showing Form - In your Spring Controller
    • Before you show the form, you must add a model attribute
    • This is a bean that will hold form data for the data binding

Development Process - Spring MVC "form" Tag (Project 5 - Part 3 - Version 1)
    1. Create Student class
    2. Create Student controller class
    3. Create HTML form
    4. Create form processing code
    5. Create confirmation page

****************************************************************************************************************************************************************************************************************************************************

Java’s Standard Bean Validation API (Reference: http://www.beanvalidation.org)
    • Java has a standard Bean Validation API
    • Defines a metadata model and API for entity validation
    • Not tied to either the web tier or the persistence tier
    • Available for server-side apps and also client-side JavaFX/Swing apps

Spring and Validation
    • Spring version 4 and higher supports Bean Validation API
    • Preferred method for validation when building Spring apps
    • Simply add Validation JARs to our project

Bean Validation Features
    • required
    • validate length
    • validate numbers
    • validate with regular expressions
    • custom validation

Validation Annotations
    • @NotNull          : Checks that the annotated value is not null
    • @Min              : Must be a number >= value
    • @Max              : Must be a number <= value
    • @Size             : Size must match the given size
    • @Pattern          : Must match a regular expression pattern
    • @Future / @Past   : Date must be in future or past of given date
    • others …

We use Hibernate Validator as it is fully compliant with "Java’s Standard Bean Validation API": http://www.hibernate.org/validator